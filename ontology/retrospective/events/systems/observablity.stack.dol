system observability.stack @ 1.0.0 {
  requires event.broadcasting >= 0.0.1
  requires health.aggregation >= 0.0.1
  requires metric.exposition >= 0.0.1
  requires websocket.streaming >= 0.0.1
  requires http.observability >= 0.0.1
  requires tracing.context >= 0.0.1
}

exegesis {
  The observability stack system composes all observability capabilities into
  a production-ready monitoring solution. Implemented across the observability
  crate with entry points in lib.rs, this system provides:

  **Architecture**:
  ```
  ┌─────────────────────────────────────────────────────────┐
  │                  Observability Layer                     │
  ├─────────────┬─────────────┬─────────────┬───────────────┤
  │   Tracing   │   Metrics   │   Health    │    Events     │
  │  (tracing)  │ (prometheus)│   Server    │  (WebSocket)  │
  ├─────────────┴─────────────┴─────────────┴───────────────┤
  │                 Orchestrator Components                  │
  └─────────────────────────────────────────────────────────┘
  ```

  **Initialization Sequence**:
  1. init_tracing(TracingConfig) - Set up structured logging
  2. MetricsRegistry::new() - Install Prometheus exporter
  3. HealthChecker::new("service", "version") - Create health tracker
  4. EventHub::default() - Create event broadcaster (1024 capacity)
  5. ObservabilityServer::new(config, health_checker) - Build HTTP server
  6. server.with_metrics(registry).with_event_hub(hub) - Wire dependencies
  7. server.serve().await - Start listening on 0.0.0.0:9090

  **Integration Points**:
  - Orchestrator components call event_hub.broadcast_*() for state changes
  - Metrics recorded via orchestrator_metrics.inc_*() and .record_*()
  - Health updated via health_checker.mark_healthy/degraded/unhealthy()
  - Clients connect to ws:
  - Prometheus scrapes http:
  - Kubernetes probes check /readyz and /livez endpoints

  **Concurrency Model**:
  All components use Arc<RwLock<>> for shared state, enabling:
  - Multiple concurrent readers (health checks, metric scrapes)
  - Exclusive writers for updates (component health, subscriptions)
  - Lock-free event broadcasting via tokio::sync::broadcast

  The system supports merging additional routes via with_additional_routes(),
  allowing the observability server to serve REST API endpoints alongside
  observability endpoints on a single port.
}
