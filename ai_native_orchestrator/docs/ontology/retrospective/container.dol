# Container Domain Ontology
# Retrospective analysis of container_runtime module
# Generated from: container_runtime_interface/, container_runtime/

@domain container
@version 1.0.0

# =============================================================================
# GENES - Core data structures representing container concepts
# =============================================================================

gene ContainerConfig {
  description: "Configuration for creating a container instance"
  properties {
    id: ContainerId           # Unique container identifier
    image: String             # OCI image reference
    command: Vec<String>      # Entrypoint command and arguments
    env: HashMap<String, String>  # Environment variables
    working_dir: Option<String>   # Working directory inside container
    mounts: Vec<Mount>        # Volume/bind mounts
    labels: HashMap<String, String>  # Metadata labels
  }
}

gene ContainerStatus {
  description: "Runtime status of a container"
  properties {
    id: ContainerId
    state: ContainerState     # Running, Stopped, Created, Unknown
    pid: Option<i32>          # Process ID if running
    exit_code: Option<i32>    # Exit code if stopped
    started_at: Option<DateTime>
    finished_at: Option<DateTime>
    error: Option<String>     # Error message if failed
  }
}

gene ContainerState {
  description: "Lifecycle state enumeration"
  variants {
    Created   # Container exists but not started
    Running   # Container process is active
    Stopped   # Container exited normally
    Failed    # Container exited with error
    Unknown   # State cannot be determined
  }
}

gene ResourceLimits {
  description: "Resource constraints for container execution"
  properties {
    cpu_cores: Option<f64>        # CPU limit in cores
    memory_bytes: Option<u64>     # Memory limit in bytes
    cpu_shares: Option<u64>       # Relative CPU weight
    memory_reservation: Option<u64>  # Soft memory limit
  }
}

gene Mount {
  description: "Filesystem mount specification"
  properties {
    source: PathBuf           # Host path or volume name
    destination: PathBuf      # Container path
    mount_type: MountType     # bind, volume, tmpfs
    read_only: bool
    propagation: Option<String>
  }
}

gene OciBundle {
  description: "OCI runtime bundle structure"
  properties {
    path: PathBuf             # Bundle root directory
    config_path: PathBuf      # config.json location
    rootfs_path: PathBuf      # Root filesystem path
  }
}

# =============================================================================
# TRAITS - Behavioral capabilities of the container subsystem
# =============================================================================

trait ContainerRuntime {
  description: "Core container lifecycle management interface"

  # Node initialization
  async fn init_node() -> Result<()>

  # Container lifecycle
  async fn create_container(config: ContainerConfig) -> Result<ContainerId>
  async fn start_container(id: ContainerId) -> Result<()>
  async fn stop_container(id: ContainerId, timeout: Duration) -> Result<()>
  async fn remove_container(id: ContainerId, force: bool) -> Result<()>

  # Container inspection
  async fn get_container_status(id: ContainerId) -> Result<ContainerStatus>
  async fn list_containers() -> Result<Vec<ContainerStatus>>

  # Container I/O
  async fn get_container_logs(id: ContainerId, tail: Option<u32>) -> Result<String>
}

trait OciBundleManager {
  description: "OCI bundle preparation and cleanup"

  fn create_bundle(config: ContainerConfig) -> Result<OciBundle>
  fn prepare_rootfs(bundle: &OciBundle, image: &str) -> Result<()>
  fn write_config_json(bundle: &OciBundle, spec: &OciSpec) -> Result<()>
  fn cleanup_bundle(bundle: &OciBundle) -> Result<()>
}

trait ImageHandler {
  description: "Container image management"

  async fn pull_image(reference: &str) -> Result<ImageId>
  async fn image_exists(reference: &str) -> Result<bool>
  fn extract_rootfs(image: &ImageId, target: &Path) -> Result<()>
}

# =============================================================================
# CONSTRAINTS - Rules governing container behavior
# =============================================================================

constraint LifecycleOrdering {
  description: "Valid container state transitions"
  rules {
    Created -> [Running, Removed]
    Running -> [Stopped, Failed]
    Stopped -> [Running, Removed]
    Failed -> [Removed]
  }
}

constraint ResourceBounds {
  description: "Resource allocation limits"
  rules {
    cpu_cores >= 0.001 when cpu_cores.is_some()
    memory_bytes >= 4_194_304 when memory_bytes.is_some()  # Minimum 4MB
    memory_reservation <= memory_bytes when both.are_some()
  }
}

constraint NamespaceIsolation {
  description: "Linux namespace isolation requirements"
  rules {
    pid_namespace: isolated_per_container
    network_namespace: configurable
    mount_namespace: isolated_per_container
    uts_namespace: isolated_per_container
    ipc_namespace: configurable
    user_namespace: optional
  }
}

constraint PathSafety {
  description: "Filesystem path security constraints"
  rules {
    mount.destination must_be absolute_path
    mount.destination must_not escape_rootfs
    bundle.path must_be writable
    rootfs must_be read_only or overlay
  }
}

# =============================================================================
# SYSTEMS - Composed behaviors and workflows
# =============================================================================

system ContainerLifecycleManager {
  description: "Orchestrates full container lifecycle"
  uses [ContainerRuntime, OciBundleManager, ImageHandler]

  workflow create_and_start(config: ContainerConfig) {
    1. Validate config against ResourceBounds
    2. Pull or verify image via ImageHandler
    3. Create OCI bundle via OciBundleManager
    4. Create container via ContainerRuntime
    5. Start container via ContainerRuntime
    6. Emit ContainerStarted event
  }

  workflow graceful_stop(id: ContainerId, timeout: Duration) {
    1. Send SIGTERM to container process
    2. Wait up to timeout for graceful exit
    3. If timeout exceeded, send SIGKILL
    4. Collect exit status
    5. Emit ContainerStopped event
  }

  workflow cleanup(id: ContainerId) {
    1. Stop container if running
    2. Remove container via ContainerRuntime
    3. Cleanup bundle via OciBundleManager
    4. Release resources
  }
}

system LogCollector {
  description: "Container log management"
  uses [ContainerRuntime]

  workflow stream_logs(id: ContainerId) {
    1. Open container stdout/stderr streams
    2. Multiplex streams with source labels
    3. Buffer and forward to log aggregator
    4. Handle container exit gracefully
  }
}

# =============================================================================
# IMPLEMENTATIONS - Concrete realizations
# =============================================================================

implementation MockRuntime of ContainerRuntime {
  description: "In-memory mock for testing"
  storage: HashMap<ContainerId, ContainerStatus>
  behavior: Synchronous state transitions without real processes
}

implementation YoukiRuntime of ContainerRuntime {
  description: "Production runtime using Youki OCI runtime"
  executable: "youki"
  bundle_dir: /var/lib/orchestrator/bundles
  state_dir: /run/orchestrator/containers

  features {
    cgroups_v2: supported
    rootless: supported
    seccomp: supported
  }
}

implementation YoukiCliRuntime of ContainerRuntime {
  description: "CLI-based Youki integration"
  invocation: subprocess
  communication: exit_codes + stdout
}
